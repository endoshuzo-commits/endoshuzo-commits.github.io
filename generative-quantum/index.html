<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Generative Gallery | Still Latency</title>
  <style>
    :root{
      --bg:#0b0d10;
      --fg:#e8e8e8;
      --muted:#a9b0bb;
      --line:#2a2f38;
      --link:#c7d2ff;
      --card:#11141a;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   "Noto Sans JP","Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      line-height:1.6;
    }
    a{color:var(--link);text-decoration:none;}
    a:hover{text-decoration:underline;}
    button{
      background:transparent;border:1px solid var(--line);color:var(--fg);
      padding:8px 10px;border-radius:10px;cursor:pointer;
    }
    button:hover{border-color:#3a4150;}

    /* Layout */
    .wrap{min-height:100%;display:flex;flex-direction:column;}
    header{
      position:sticky;top:0;z-index:10;
      display:flex;align-items:center;justify-content:space-between;
      padding:14px 18px;border-bottom:1px solid var(--line);
      background:rgba(11,13,16,.72);backdrop-filter: blur(10px);
    }
    header .left{display:flex;gap:12px;align-items:baseline;flex-wrap:wrap;}
    header .title{font-size:14px;letter-spacing:.02em;}
    header .desc{font-size:12px;color:var(--muted);}
    header .right{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted);}

    main{
      max-width:1100px;
      margin: 28px auto 64px;
      padding: 0 18px;
      width:100%;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap:22px;
    }

    .card{
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(17,20,26,.55);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: border-color .15s ease, transform .15s ease;
    }
    .card:hover{
      border-color:#3a4150;
      transform: translateY(-1px);
    }

    .thumb{
      width:100%;
      aspect-ratio: 16 / 10;
      display:block;
      background:#0a0c10;
    }

    .meta{
      padding:14px 14px 16px;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .name{
      font-size:16px;
      margin:0 0 6px;
      letter-spacing:.01em;
    }
    .cap{
      font-size:13px;
      margin:0;
      color:var(--muted);
    }

    .hint{
      margin:0 0 18px;
      color:var(--muted);
      font-size:13px;
    }
    .kbd{
      display:inline-block;
      border:1px solid rgba(255,255,255,.16);
      border-bottom-color: rgba(255,255,255,.10);
      padding:2px 8px;border-radius:999px;
      font-size:12px;color:rgba(255,255,255,.75);
      background: rgba(0,0,0,.15);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="left">
        <div class="title">Generative Gallery</div>
        <div class="desc">これらの作品は常に生成され続けている<br>
しかし表示された瞬間にのみ像が確定する<br>

観測は可能性を一つに収束させる<br>
あなたが見ているのは<br>
無数の重ね合わせから偶然選ばれた，ただ一度の結果である
        </div>
      </div>
      <div class="right">
        <a href="../">← Still Latency</a>
        <button id="regen" title="展示室をリロードしてサムネを描き直す">リロード</button>
      </div>
    </header>

    <main>
      <p class="hint">
        <span class="kbd">クリック</span> または <span class="kbd">Enter</span> で個室を開く（新しいタブ）。
      </p>
      <div class="grid" id="grid"></div>
    </main>
  </div>

<script>
(() => {
  const grid = document.getElementById("grid");
  document.getElementById("regen").addEventListener("click", () => location.reload());

  // =========================================================
  // Works
  // =========================================================
  const WORKS = [
    { id:"flowfield", title:"Flow Field", desc:"場に沿って筆致が流れる", renderer: renderFlowField },
    { id:"rings",     title:"Rings",     desc:"干渉縞のような円環",     renderer: renderRings },
    { id:"shards",    title:"Shards",    desc:"割れた光片の抽象構成",   renderer: renderShards },

    // --- Abstract painting series (signature separated) ---
    { id:"abstract_constructive", title:"Abstract / Constructive", desc:"構成的抽象：色面・線・円弧・格子", renderer: renderAbstractConstructive },
    { id:"abstract_gestural",     title:"Abstract / Gestural",     desc:"身振りの抽象：筆致・滲み・飛沫",     renderer: renderAbstractGestural },
    { id:"abstract_hybrid",       title:"Abstract / Hybrid",       desc:"混成的中小：断層で衝突する二層", renderer: renderAbstractHybrid },
  ];

  // =========================================================
  // Build cards
  // =========================================================
  build();

  function build(){
    grid.innerHTML = "";
    for (const w of WORKS){
      const card = document.createElement("div");
      card.className = "card";
      card.tabIndex = 0;
      card.setAttribute("role", "button");
      card.setAttribute("aria-label", `${w.title} を開く`);

      const canvas = document.createElement("canvas");
      canvas.className = "thumb";

      // 16:10 の比率でピクセルを確保（Retina対応）
      const W = 640, H = Math.floor(640 * 10/16);
      const dpr = devicePixelRatio || 1;
      canvas.width = Math.floor(W * dpr);
      canvas.height = Math.floor(H * dpr);

      const ctx = canvas.getContext("2d", { alpha:false });
      ctx.setTransform(dpr,0,0,dpr,0,0);

      // thumb state（軽量な“見本”）
      const s = makeThumbState(w.id);

      try {
        w.renderer(ctx, W, H, s, { isThumb:true, dpr }); // ★dprを渡す
      } catch (e) {
        console.error("[thumb render failed]", w.id, e);
        ctx.fillStyle = "rgb(10,12,16)";
        ctx.fillRect(0,0,W,H);
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.lineWidth = 1;
        ctx.strokeRect(12, 12, W-24, H-24);
      }

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = `
        <p class="name">${escapeHtml(w.title)}</p>
        <p class="cap">${escapeHtml(w.desc)}</p>
      `;

      card.appendChild(canvas);
      card.appendChild(meta);

      // クリックで個室を新タブ表示
      const open = () => {
        window.open(`viewer.html?work=${encodeURIComponent(w.id)}`, "_blank", "noopener");
      };
      card.addEventListener("click", open);
      card.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") { ev.preventDefault(); open(); }
      });

      grid.appendChild(card);
    }
  }

  // =========================================================
  // States / Palette
  // =========================================================
  function makeThumbState(workId){
    // 「workIdごとの系統」をまず固定
    const base = hash32("thumb|" + workId) >>> 0;

    // その系統の中でだけランダム（=別作品と混ざらない）
    const salt = (Math.random()*1e9) >>> 0;
    const seed = (base ^ salt) >>> 0;

    return {
      seed,
      t: Math.random() * 50,
      field: {
        a: 0.6 + mulberry32(seed)()*1.2,
        b: 0.6 + mulberry32(seed+1)()*1.2,
        c: 0.6 + mulberry32(seed+2)()*1.2,
        d: 0.6 + mulberry32(seed+3)()*1.2
      },
      palette: makePalette(seed),
      abs: makeAbstractParams(seed, workId)
    };
  }

  function makePalette(seed){
    const inks = [
      "rgba(199,210,255,1)",
      "rgba(255,210,199,1)",
      "rgba(199,255,233,1)",
      "rgba(255,255,255,1)"
    ];
    return { bg: "rgb(10,12,16)", ink: shuffle(inks, seed).slice(0,3) };
  }

  // 抽象画用の “紙/絵具” パレット（サムネでも見える寄り）
  function makeAbstractParams(seed, workId){
  const rnd = mulberry32(seed);

  // 背景を作品タイプで固定
  const PAL_LIGHT = {
    name:"dusty",
    bg:"#efe7d8",
    inks:["#11141a","#263238","#c62828","#1565c0","#2e7d32","#f9f5ef"]
  };

  const PAL_DARK = {
    name:"cold-fire",
    bg:"#071018",
    inks:["#b2ebf2","#4dd0e1","#1565c0","#ff1744","#ffd180","#ffffff","#0b0d10"]
  };

  const pal = (workId === "abstract_hybrid") ? PAL_DARK : PAL_LIGHT;

  return {
    pal,
    paper: 0.10 + rnd()*0.10,
    vignette: (workId === "abstract_hybrid")
      ? (0.45 + rnd()*0.20)   // 暗い方はやや強め
      : (0.28 + rnd()*0.18)   // 明るい方は弱め
  };
}

  // =========================================================
  // Renderers (existing)
  // =========================================================
  function renderFlowField(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const particles = makeParticles(W, H, Math.max(220, Math.floor((W*H)/2200)), s.seed);

    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = Math.max(0.8, Math.min(W,H) * 0.0020);

    for (let layer=0; layer<3; layer++){
      ctx.strokeStyle = s.palette.ink[layer % s.palette.ink.length];
      ctx.globalAlpha = 0.20 + layer * 0.12;

      for (let i=0; i<particles.length; i++){
        drawFlowStroke(ctx, particles[i], s, W, H, 55 + layer*22);
      }
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  function drawFlowStroke(ctx, p, s, W, H, steps){
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);

    let x=p.x, y=p.y;
    const t0=s.t;

    for (let k=0; k<steps; k++){
      const v = fieldVec(x,y,t0,s,W,H);
      x += v.vx;
      y += v.vy;
      if (x<-20 || y<-20 || x>W+20 || y>H+20) break;
      ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function fieldVec(x,y,t,s,W,H){
    const nx=(x/W)*2-1;
    const ny=(y/H)*2-1;

    const f=s.field;
    const u = Math.sin((nx*f.a + t*0.7)*Math.PI) + Math.cos((ny*f.b - t*0.5)*Math.PI);
    const v = Math.cos((ny*f.c + t*0.6)*Math.PI) - Math.sin((nx*f.d - t*0.4)*Math.PI);

    const ang = Math.atan2(v,u);
    const mag = 1.2 + 0.9*(Math.sin(u*1.3)*Math.cos(v*1.1));
    const sp  = Math.min(W,H)*0.0032;

    return { vx: Math.cos(ang)*mag*sp, vy: Math.sin(ang)*mag*sp };
  }

  function renderRings(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const rnd = mulberry32(s.seed);
    const cx = W*(0.35 + rnd()*0.30);
    const cy = H*(0.35 + rnd()*0.30);

    ctx.globalCompositeOperation = "screen";
    ctx.lineWidth = Math.max(1.0, Math.min(W,H)*0.0021);

    const step = Math.max(3.5, Math.min(W,H)/90);
    const rings = Math.floor(Math.min(W,H)/step);

    for (let i=0; i<rings; i++){
      const baseR = i * step;
      const jitter = (rnd()-0.5) * step * 0.6;
      const r = Math.max(0.15, baseR + jitter);

      const t = i / rings;
      const centerBoost = 1.0 - 0.65*t;
      const w = 0.5 + 0.7*Math.sin(i*0.15 + s.t);

      ctx.strokeStyle = s.palette.ink[i % s.palette.ink.length];
      ctx.globalAlpha = Math.max(0.06, (0.16 + 0.22*w) * centerBoost);

      const rx = r * (1.0 + 0.08*Math.sin(i*0.07));
      const ry = r;

      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, (rnd()-0.5)*0.2, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  function renderShards(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const rnd = mulberry32(s.seed);
    ctx.globalCompositeOperation = "lighter";

    const n = Math.max(18, Math.floor((W*H)/22000));

    for (let i=0; i<n; i++){
      const x=rnd()*W, y=rnd()*H;
      const size = 22 + rnd()*140;
      const ang = rnd()*Math.PI*2;

      ctx.fillStyle = s.palette.ink[i % s.palette.ink.length];
      ctx.globalAlpha = 0.08 + rnd()*0.14;

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(-size*0.5, -size*0.2);
      ctx.lineTo( size*0.55, -size*0.05);
      ctx.lineTo( size*0.25,  size*0.35);
      ctx.lineTo(-size*0.45,  size*0.25);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  // =========================================================
  // Renderers (abstract painting) — signature separated
  // =========================================================

  // Constructive: 硬い / 構造だけで勝負（smearを使わない）
  function renderAbstractConstructive(ctx, W, H, s, opt){
    const rng = sfc32Seeded(s.seed ^ 0xA31D1B1F);
    const pal = s.abs?.pal || makeAbstractParams(s.seed).pal;

    fillBg(ctx, W, H, pal.bg);
    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.06 : 0.10);

    constructiveLayer(ctx, W, H, rng, pal, opt);

    // smearLayer は入れない（ここが「硬さ」の署名）
    // smearLayer(ctx, W, H, rng, opt?.isThumb ? 10 : 20);

    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.04 : 0.06);
    vignette(ctx, W, H, opt?.isThumb ? 0.18 : 0.28);
  }

  // Gestural: 柔らかい / 墨の滲み（inkBleed）を入れて署名を固定
  function renderAbstractGestural(ctx, W, H, s, opt){
    const rng = sfc32Seeded(s.seed ^ 0x19C0FFEE);
    const pal = s.abs?.pal || makeAbstractParams(s.seed).pal;

    fillBg(ctx, W, H, pal.bg);
    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.08 : 0.12);

    gesturalLayer(ctx, W, H, rng, pal, opt);
    inkBleed(ctx, W, H, rng); // ★滲み（署名）
    smearLayer(ctx, W, H, rng, opt?.isThumb ? 90 : 160);

    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.05 : 0.07);
    vignette(ctx, W, H, opt?.isThumb ? 0.24 : 0.38);
  }

  // Hybrid: 断層（裂け目）で二層が衝突していることを見せる
  function renderAbstractHybrid(ctx, W, H, s, opt){
    const rng = sfc32Seeded(s.seed ^ 0x55AA0F0F);
    const pal = s.abs?.pal || makeAbstractParams(s.seed).pal;
    const dpr = opt?.dpr || 1;

    fillBg(ctx, W, H, pal.bg);
    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.08 : 0.12);

    // layer A: constructive（全面）
    constructiveLayer(ctx, W, H, rng, pal, opt);

    // layer B: gestural（別キャンバスで描いて裂け目マスク）
    const tmp = document.createElement("canvas");
    tmp.width  = Math.floor(W * dpr);
    tmp.height = Math.floor(H * dpr);
    const tctx = tmp.getContext("2d", { alpha:true });
    tctx.setTransform(dpr,0,0,dpr,0,0);

    // 透明から描く
    tctx.clearRect(0,0,W,H);
    gesturalLayer(tctx, W, H, rng, pal, opt);
    riftMask(tctx, W, H, rng); // ★裂け目（署名）

    // 合成（衝突）
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = opt?.isThumb ? 0.92 : 0.95;
    ctx.drawImage(tmp, 0, 0, W, H);
    ctx.restore();

    smearLayer(ctx, W, H, rng, opt?.isThumb ? 60 : 120);

    paperNoise(ctx, W, H, rng, opt?.isThumb ? 0.05 : 0.07);
    vignette(ctx, W, H, opt?.isThumb ? 0.26 : 0.42);
  }

  function constructiveLayer(ctx, W, H, rng, pal, opt){
    ctx.save();

    // 色面ブロック
    const blocks = opt?.isThumb ? 4 : 7;
    for (let i=0;i<blocks;i++){
      const x = rng()*W*0.95, y = rng()*H*0.95;
      const w = lerp(W*0.12, W*0.55, rng());
      const h = lerp(H*0.10, H*0.42, rng());
      const rot = (rng()-0.5)*0.7;

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);
      ctx.globalAlpha = lerp(0.10, 0.26, rng());
      ctx.fillStyle = pick(rng, pal.inks);
      ctx.fillRect(-w/2, -h/2, w, h);
      ctx.restore();
    }

    // グリッド
    const grids = opt?.isThumb ? 2 : 4;
    for (let g=0; g<grids; g++){
      const x = rng()*W, y = rng()*H;
      const w = lerp(140, 420, rng());
      const h = lerp(90, 290, rng());
      const rot = (rng()-0.5)*0.9;
      const cell = lerp(10, 26, rng());

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);
      ctx.globalAlpha = lerp(0.10, 0.22, rng());
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.lineWidth = 1;

      for (let yy=-h/2; yy<=h/2; yy+=cell){
        ctx.beginPath(); ctx.moveTo(-w/2, yy); ctx.lineTo(w/2, yy); ctx.stroke();
      }
      for (let xx=-w/2; xx<=w/2; xx+=cell){
        ctx.beginPath(); ctx.moveTo(xx, -h/2); ctx.lineTo(xx, h/2); ctx.stroke();
      }
      ctx.restore();
    }

    // 円 / 円弧 / 三角
    const shapes = opt?.isThumb ? 10 : 18;
    for (let i=0;i<shapes;i++){
      const x=rng()*W, y=rng()*H;
      const r = Math.max(6, Math.abs(rnorm(rng)) * lerp(14, 120, rng()));
      const kind = (rng()*3)|0;
      const ink = pick(rng, pal.inks);

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((rng()-0.5)*1.4);

      if (kind === 0){
        ctx.globalAlpha = lerp(0.10, 0.28, rng());
        ctx.fillStyle = ink;
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      } else if (kind === 1){
        ctx.globalAlpha = lerp(0.16, 0.44, rng());
        ctx.strokeStyle = ink;
        ctx.lineWidth = lerp(1.2, 4.6, rng());
        const a0 = rng()*Math.PI*2;
        const a1 = a0 + lerp(Math.PI*0.35, Math.PI*1.5, rng());
        ctx.beginPath(); ctx.arc(0,0,r,a0,a1); ctx.stroke();
      } else {
        ctx.globalAlpha = lerp(0.10, 0.26, rng());
        ctx.fillStyle = ink;
        ctx.beginPath();
        ctx.moveTo(-r*0.6,  r*0.45);
        ctx.lineTo( r*0.7,  0);
        ctx.lineTo(-r*0.2, -r*0.55);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    // 走る線（太め）
    ctx.globalCompositeOperation = "multiply";
    ctx.lineCap = "round";
    const lines = opt?.isThumb ? 16 : 30;
    for (let i=0;i<lines;i++){
      const x0=rng()*W, y0=rng()*H;
      const x1=rng()*W, y1=rng()*H;
      const cx = lerp(x0,x1,0.5) + rnorm(rng)*90;
      const cy = lerp(y0,y1,0.5) + rnorm(rng)*90;

      ctx.strokeStyle = "rgba(0,0,0,0.85)";
      ctx.globalAlpha = lerp(0.10, 0.36, rng());
      ctx.lineWidth = lerp(1.0, 5.8, rng());
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(cx,cy,x1,y1);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 1;
  }

  function gesturalLayer(ctx, W, H, rng, pal, opt){
    ctx.save();

    // 色場（霞）
    ctx.globalCompositeOperation = "screen";
    const clouds = opt?.isThumb ? 5 : 10;
    for (let i=0;i<clouds;i++){
      const x=rng()*W, y=rng()*H;
      const rx=lerp(W*0.10, W*0.40, rng());
      const ry=lerp(H*0.10, H*0.36, rng());
      const rot=(rng()-0.5)*1.0;

      const grad = ctx.createRadialGradient(x,y,0,x,y,Math.max(rx,ry));
      const c = pick(rng, pal.inks);
      grad.addColorStop(0, c);
      grad.addColorStop(1, "rgba(0,0,0,0)");

      ctx.globalAlpha = lerp(0.06, 0.18, rng());
      ctx.save();
      ctx.translate(x,y); ctx.rotate(rot); ctx.translate(-x,-y);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // 太い筆致
    ctx.globalCompositeOperation = "overlay";
    ctx.lineCap = "round";
    const strokes = opt?.isThumb ? 12 : 24;
    for (let i=0;i<strokes;i++){
      ctx.strokeStyle = pick(rng, pal.inks);
      ctx.lineWidth = lerp(6, opt?.isThumb ? 26 : 44, rng());
      ctx.globalAlpha = lerp(0.03, 0.12, rng());

      const x0=rng()*W, y0=rng()*H;
      const x1=rng()*W, y1=rng()*H;
      const cx = (x0+x1)/2 + rnorm(rng)*200;
      const cy = (y0+y1)/2 + rnorm(rng)*180;

      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(cx,cy,x1,y1);
      ctx.stroke();
    }

    // スクラッチ（細線）
    ctx.globalCompositeOperation = "multiply";
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,0.85)";
    ctx.globalAlpha = 0.10;

    const scratches = opt?.isThumb ? 160 : 320;
    for (let i=0;i<scratches;i++){
      const x=rng()*W, y=rng()*H;
      const ang=rng()*Math.PI*2;
      const len=Math.abs(rnorm(rng))*lerp(10, opt?.isThumb ? 90 : 140, rng());
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
      ctx.stroke();
    }

    // 飛沫（アクセント）
    const accent = pick(rng, ["#ff1744","#00e5ff","#ffd180","#ffffff"]);
    splatter(ctx, W, H, rng, accent, opt?.isThumb);

    ctx.restore();
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 1;
  }

  // =========================================================
  // Signature helpers (NEW)
  // =========================================================

  // Gestural署名：滲み（墨が紙に広がる感じ）
  function inkBleed(ctx, W, H, rng){
    ctx.save();
    ctx.globalCompositeOperation = "multiply";
    ctx.globalAlpha = 0.10;

    const n = 40;
    for(let i=0;i<n;i++){
      const x=rng()*W, y=rng()*H;
      const rx=lerp(40, 220, rng());
      const ry=lerp(30, 180, rng());
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(x,y,rx,ry, rng()*Math.PI*2, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  // Hybrid署名：裂け目マスク（帯状に“ちぎれた”形で残す）
  function riftMask(ctx, W, H, rng){
    ctx.save();
    ctx.globalCompositeOperation = "destination-in";
    ctx.fillStyle = "rgba(255,255,255,1)";

    const bandY = H*(0.35 + rng()*0.30);
    const bandH = lerp(H*0.18, H*0.32, rng());

    ctx.beginPath();
    ctx.moveTo(0, bandY - bandH/2);
    const seg = 10;

    for(let i=1;i<=seg;i++){
      const x = (W/seg)*i;
      const y = bandY - bandH/2 + rnorm(rng)*18;
      ctx.lineTo(x,y);
    }
    for(let i=seg;i>=0;i--){
      const x = (W/seg)*i;
      const y = bandY + bandH/2 + rnorm(rng)*18;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  // -------------------------
  // Abstract helpers
  // -------------------------
  function fillBg(ctx, W, H, color){
    ctx.fillStyle = color;
    ctx.fillRect(0,0,W,H);
  }

  function paperNoise(ctx, W, H, rng, strength){
    ctx.save();
    ctx.globalAlpha = strength;
    const count = Math.floor((W*H) / 4500);
    for (let i=0;i<count;i++){
      const x = rng()*W, y=rng()*H;
      const a = rng()*0.35;
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fillRect(x,y,1,1);
    }
    ctx.restore();
  }

  function smearLayer(ctx, W, H, rng, n){
    ctx.save();
    ctx.globalCompositeOperation = "overlay";
    ctx.lineCap = "round";
    for (let i=0;i<n;i++){
      const x0=rng()*W, y0=rng()*H;
      const ang=rng()*Math.PI*2;
      const len=lerp(40, 420, rng());
      const w=lerp(1.0, 5.0, rng());
      ctx.lineWidth = w;
      ctx.globalAlpha = lerp(0.02, 0.10, rng());
      ctx.strokeStyle = `rgba(255,255,255,${lerp(0.2,0.9,rng())})`;
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.lineTo(x0 + Math.cos(ang)*len, y0 + Math.sin(ang)*len);
      ctx.stroke();
    }
    ctx.restore();
  }

  function splatter(ctx, W, H, rng, col, isThumb){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const bursts = isThumb ? 3 : Math.floor(lerp(3, 7, rng()));
    for (let b=0;b<bursts;b++){
      const cx=rng()*W, cy=rng()*H;
      const dots = isThumb ? 220 : Math.floor(lerp(220, 520, rng()));
      for (let i=0;i<dots;i++){
        const rr = Math.abs(rnorm(rng)) * lerp(12, isThumb ? 90 : 150, rng());
        const ang = rng()*Math.PI*2;
        const x = cx + Math.cos(ang)*rr;
        const y = cy + Math.sin(ang)*rr;
        const s = lerp(0.8, 2.8, rng()) * (0.5 + rng());
        ctx.globalAlpha = lerp(0.03, 0.12, rng());
        ctx.fillStyle = col;
        ctx.fillRect(x,y,s,s);
      }
    }
    ctx.restore();
  }

  function vignette(ctx, W, H, strength){
    ctx.save();
    const g = ctx.createRadialGradient(
      W*0.5,H*0.5, Math.min(W,H)*0.25,
      W*0.5,H*0.5, Math.max(W,H)*0.80
    );
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, `rgba(0,0,0,${strength})`);
    ctx.fillStyle = g;
    ctx.globalAlpha = 0.65;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // =========================================================
  // Utils
  // =========================================================
  function makeParticles(W,H,n,seed){
    const rnd = mulberry32(seed);
    const ps = new Array(n);
    for (let i=0; i<n; i++) ps[i] = { x:rnd()*W, y:rnd()*H };
    return ps;
  }

  function grain(ctx, W, H, seed){
    const rnd = mulberry32(seed + 12345);
    const count = Math.floor((W*H)/8000);
    ctx.fillStyle = "white";
    for (let i=0; i<count; i++) ctx.fillRect(rnd()*W, rnd()*H, 1, 1);
  }

  function mulberry32(a){
    a = (a >>> 0);
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // sfc32 を seed から生成（抽象画向け：安定に使う）
  function sfc32Seeded(seed){
    const a = (seed ^ 0x9E3779B9) >>> 0;
    const b = (seed ^ 0x243F6A88) >>> 0;
    const c = (seed ^ 0xB7E15162) >>> 0;
    const d = (seed ^ 0xDEADBEEF) >>> 0;
    return sfc32(a,b,c,d);
  }
  function sfc32(a,b,c,d){
    return function(){
      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
      let t = (a + b) | 0;
      a = b ^ (b >>> 9);
      b = (c + (c << 3)) | 0;
      c = (c << 21) | (c >>> 11);
      d = (d + 1) | 0;
      t = (t + d) | 0;
      c = (c + t) | 0;
      return (t >>> 0) / 4294967296;
    };
  }

  function shuffle(arr, seed){
    const rnd = mulberry32(seed);
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(rnd()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function hash32(str){
    // FNV-1a 32bit
    let h = 0x811c9dc5;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 0x01000193);
    }
    return h >>> 0;
  }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function pick(rng, arr){ return arr[(rng()*arr.length)|0]; }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function rnorm(rng){
    // Box-Muller
    const u = Math.max(1e-9, rng()), v = rng();
    return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
  }
})();
</script>
</body>
</html>
